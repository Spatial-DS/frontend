# floorplan/data_models.py
from dataclasses import dataclass, field
from typing import Literal

import numpy as np
import pandas as pd
from deap import base, creator
from pydantic import BaseModel, Field
from shapely.geometry import Polygon

# --- 1. GA Individual Definition ---
# Kept as is for DEAP compatibility
if not hasattr(creator, "FitnessMin"):
    creator.create("FitnessMin", base.Fitness, weights=(-1.0,))
if not hasattr(creator, "Individual"):
    creator.create("Individual", dict, fitness=creator.FitnessMin)

Individual = creator.Individual

# --- 2. API Input Models (Pydantic) ---
# Used for Validation and Request Body


class Connection(BaseModel):
    """Represents a point of vertical circulation."""

    coord: tuple[float, float]
    connection_id: str
    type_name: str  # e.g., 'lif', 'stair'


class FloorPlan(BaseModel):
    """Defines the geometric and fixed elements for a single floor."""

    name: str
    boundary: list[tuple[float, float]]
    walls: list[list[tuple[float, float]]] = Field(default_factory=list)
    # dictionary mapping room type (e.g., 'ent') to a list of coordinate points
    fixed_elements: dict[str, list[tuple[float, float]]] = Field(default_factory=dict)
    connections: list[Connection] = Field(default_factory=list)


class ZoneConstraint(BaseModel):
    """Defines area requirements for a specific zone (replaces selected_zones.csv)."""

    short_code: str
    area_value: float | None = None
    unit: Literal["sqm", "percent", ""] = "sqm"


class GlobalParameters(BaseModel):
    """Configuration for the optimization run."""

    total_gfa: float
    target_node_counts: list[int] = Field(default=[50, 300, 500])
    generations: list[int] = Field(default=[100, 100, 100])
    pop_sizes: list[int] = Field(default=[20, 50, 20])
    text_prompt: str | None = ""
    # Toggle for interactive vs headless mode (default headless for API)
    interactive: bool = False


class OptimizationRequest(BaseModel):
    """The top-level payload sent to the API."""

    floor_plans: list[FloorPlan]
    constraints: list[ZoneConstraint]
    global_parameters: GlobalParameters


# --- 3. API Output Models (Pydantic) ---
# Used to structure the JSON result stored in the DB and returned to Frontend


class ZonePolygon(BaseModel):
    """A single zone's shape on a specific floor."""

    type: str
    # list of [x, y] coordinates forming the polygon
    polygon: list[list[float]]


class FloorLayout(BaseModel):
    """The result layout for a single floor."""

    floor_name: str
    zones: list[ZonePolygon]


# --- 4. Internal Data Structures (Dataclasses) ---
# Used for heavy lifting in geometry.py, graph.py, etc.


@dataclass
class RoomData:
    """Container for room and rule information (merged static + dynamic data)."""

    room_df: pd.DataFrame
    rules_df: pd.DataFrame
    selected_zones_df: pd.DataFrame | None = None


@dataclass
class FloorGeometry:
    """Holds the processed geometric data for a single floor."""

    name: str
    polygon: Polygon
    original_polygon: Polygon  # The unscaled, final polygon
    min_xy: np.ndarray
    scale: float
    fixed_nodes: dict[str, list[int]] = field(default_factory=dict)


@dataclass
class DiscretizedGraph:
    """Holds the complete, node-and-edge representation of the floor plan graph."""

    grid_positions: np.ndarray
    adj_indices: np.ndarray
    adj_indptr: np.ndarray
    adjacency_list: dict[int, list[int]]
    adjacency_edges_np: np.ndarray
    n_nodes: int
    floor_node_ranges: np.ndarray  # Shape (n_floors, 2) -> [start_idx, end_idx]


@dataclass
class OptimizationResult:
    """
    Structured output for a single, complete layout solution.
    Modified to include Pydantic models for easier serialization.
    """

    individual: Individual
    fitness: float
    area_distribution: pd.DataFrame
    # New: JSON-serializable polygons generated by geometry_postprocessing
    floor_layouts: list[FloorLayout] = field(default_factory=list)

    svg_render: str | None = None


@dataclass
class ScalingInfo:
    """Stores parameters needed to map between real and grid coordinates."""

    min_xy: np.ndarray
    scale: float
    n: int

    def to_grid(self, coords: np.ndarray) -> np.ndarray:
        """Converts real-world coordinates to grid coordinates."""
        # Ensure input is float for division
        coords = np.asarray(coords, dtype=float)
        return (coords - self.min_xy) / self.scale * self.n

    def to_real(self, grid_coords: np.ndarray) -> np.ndarray:
        """Converts grid coordinates back to real-world coordinates."""
        return (grid_coords / self.n) * self.scale + self.min_xy


@dataclass
class DiscretizationResult:
    """Holds all data resulting from discretizing a single floor's geometry."""

    grid_positions: np.ndarray
    scaled_polygon: Polygon
    original_polygon: Polygon
    fixed_nodes: dict[str, list[int]]
    connection_nodes: dict[str, int]  # {connection_id: node_idx}
    scaling_info: ScalingInfo
